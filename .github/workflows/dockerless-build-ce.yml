name: Dockerless Build CE

on:
  workflow_dispatch:
  push:
    branches:
      - non-docker-build

env:
  DEFAULT_TAG_NAME: v0.26.0
  MANIFEST_BUCKET: plane-terraform-state-dev

jobs:
  build_setup:
    runs-on: ubuntu-22.04
    outputs:
      tag_name: ${{ steps.set_env_variables.outputs.TAG_NAME }}
      admin_image: ${{ steps.set_env_variables.outputs.ADMIN_IMAGE }}
      web_image: ${{ steps.set_env_variables.outputs.WEB_IMAGE }}
      space_image: ${{ steps.set_env_variables.outputs.SPACE_IMAGE }}
      backend_image: ${{ steps.set_env_variables.outputs.BACKEND_IMAGE }}
      live_image: ${{ steps.set_env_variables.outputs.LIVE_IMAGE }}
    steps:
      - name: Prepare Environment
        id: set_env_variables
        run: |
          #  if the action is workflow_dispatch, then use the github.ref_name
          
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG_NAME=${{ github.ref_name }}
          else
            # get the selected branch/tag name and flatten it 
            TAG_NAME=${{ env.DEFAULT_TAG_NAME }}
          fi

          TAG_NAME=${TAG_NAME//\//-}

          echo "TAG_NAME=${TAG_NAME}" >> $GITHUB_OUTPUT

          echo "ADMIN_IMAGE=makeplane/plane-admin" >> $GITHUB_OUTPUT
          echo "WEB_IMAGE=makeplane/plane-frontend" >> $GITHUB_OUTPUT
          echo "SPACE_IMAGE=makeplane/plane-space" >> $GITHUB_OUTPUT
          echo "BACKEND_IMAGE=makeplane/plane-backend" >> $GITHUB_OUTPUT
          echo "LIVE_IMAGE=makeplane/plane-live" >> $GITHUB_OUTPUT

  # build_admin:
  #   needs: build_setup
  #   runs-on: ubuntu-22.04
  #   steps:
  #     - name: Export Builder Stage Content
  #       run: |
  #         IMAGE_NAME=${{ needs.build_setup.outputs.admin_image }}
  #         TAG_NAME=${{ needs.build_setup.outputs.tag_name }}

  #         # Create a temporary container from the builder stage
  #         CONTAINER_ID=$(docker create --platform=linux/amd64 -q ${IMAGE_NAME}:${TAG_NAME})
          
  #         # Create publish directory
  #         mkdir -p admin-dist
          
  #         # Copy the /app contents from the container
  #         docker cp $CONTAINER_ID:/app/. admin-dist/
          
  #         # Remove the temporary container
  #         docker rm $CONTAINER_ID
          
  #         # Create a tar archive
  #         tar -czf admin-dist.tar.gz admin-dist/

  #     - name: Upload Build Artifact
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: admin-dist
  #         path: admin-dist.tar.gz
  #         retention-days: 1
    
  # build_web:
  #   needs: build_setup
  #   runs-on: ubuntu-22.04
  #   steps:
  #     - name: Export Builder Stage Content
  #       run: |
  #         IMAGE_NAME=${{ needs.build_setup.outputs.web_image }}
  #         TAG_NAME=${{ needs.build_setup.outputs.tag_name }}

  #         # Create a temporary container from the builder stage
  #         CONTAINER_ID=$(docker create --platform=linux/amd64 -q ${IMAGE_NAME}:${TAG_NAME})
          
  #         # Create publish directory
  #         mkdir -p web-dist
          
  #         # Copy the /app contents from the container
  #         docker cp $CONTAINER_ID:/app/. web-dist/
          
  #         # Remove the temporary container
  #         docker rm $CONTAINER_ID
          
  #         # Create a tar archive
  #         tar -czf web-dist.tar.gz web-dist/

  #     - name: Upload Build Artifact
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: web-dist
  #         path: web-dist.tar.gz
  #         retention-days: 1

  # build_space:
  #   needs: build_setup
  #   runs-on: ubuntu-22.04
  #   steps:
  #     - name: Export Builder Stage Content
  #       run: |
  #         IMAGE_NAME=${{ needs.build_setup.outputs.space_image }}
  #         TAG_NAME=${{ needs.build_setup.outputs.tag_name }}

  #         # Create a temporary container from the builder stage
  #         CONTAINER_ID=$(docker create --platform=linux/amd64 -q ${IMAGE_NAME}:${TAG_NAME})
          
  #         # Create publish directory
  #         mkdir -p space-dist
          
  #         # Copy the /app contents from the container
  #         docker cp $CONTAINER_ID:/app/. space-dist/
          
  #         # Remove the temporary container
  #         docker rm $CONTAINER_ID
          
  #         # Create a tar archive
  #         tar -czf space-dist.tar.gz space-dist/

  #     - name: Upload Build Artifact
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: space-dist
  #         path: space-dist.tar.gz
  #         retention-days: 1
 
  # build_live:
  #   needs: build_setup
  #   runs-on: ubuntu-22.04
  #   steps:
  #     - name: Export Builder Stage Content
  #       run: |
  #         IMAGE_NAME=${{ needs.build_setup.outputs.live_image }}
  #         TAG_NAME=${{ needs.build_setup.outputs.tag_name }}

  #         # Create a temporary container from the builder stage
  #         CONTAINER_ID=$(docker create --platform=linux/amd64 -q ${IMAGE_NAME}:${TAG_NAME})
          
  #         # Create publish directory
  #         mkdir -p live-dist
          
  #         # Copy the /app contents from the container
  #         docker cp $CONTAINER_ID:/app/. live-dist/
          
  #         # Remove the temporary container
  #         docker rm $CONTAINER_ID
          
  #         # Create a tar archive
  #         tar -czf live-dist.tar.gz live-dist/

  #     - name: Upload Build Artifact
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: live-dist
  #         path: live-dist.tar.gz
  #         retention-days: 1

  # build_backend:
  #   needs: build_setup
  #   runs-on: ubuntu-22.04
  #   steps:
  #     - name: Export Builder Stage Content
  #       run: |
  #         IMAGE_NAME=${{ needs.build_setup.outputs.backend_image }}
  #         TAG_NAME=${{ needs.build_setup.outputs.tag_name }}

  #         # Create a temporary container from the builder stage
  #         CONTAINER_ID=$(docker create --platform=linux/amd64 -q ${IMAGE_NAME}:${TAG_NAME})
          
  #         # Create publish directory
  #         mkdir -p backend-dist
          
  #         # Copy the /app contents from the container
  #         docker cp $CONTAINER_ID:/code/. backend-dist/
          
  #         # Remove the temporary container
  #         docker rm $CONTAINER_ID
          
  #         # Create a tar archive
  #         tar -czf backend-dist.tar.gz backend-dist/

  #     - name: Upload Build Artifact
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: backend-dist
  #         path: backend-dist.tar.gz
  #         retention-days: 1

  # Job to build the appliance using hashicorp packer
  build_appliance:
    needs: build_setup
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.PLANE_DEV_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.PLANE_DEV_AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Download Previous Manifest
        run: |
          # Download the previous manifest from S3 if it exists
          aws s3 cp s3://${{ env.MANIFEST_BUCKET }}/plane-ce/ami/manifests/latest-manifest.json ./previous-manifest.json || true

      - name: Cleanup Old AMIs
        if: hashFiles('previous-manifest.json') != ''
        run: |
          OLD_AMI_ID=$(jq -r '.builds[-1].artifact_id' previous-manifest.json | cut -d ":" -f2)
          if [ ! -z "$OLD_AMI_ID" ]; then
            echo "Found previous AMI: $OLD_AMI_ID"
            # Deregister the old AMI
            aws ec2 deregister-image --image-id "$OLD_AMI_ID" || true
            echo "Deregistered previous AMI: $OLD_AMI_ID"
          fi

      - name: Setup `packer`
        uses: hashicorp/setup-packer@main
        id: setup
        with:
          version: latest

      - name: Run `packer init`
        id: init
        run: "packer init ./image.pkr.hcl"

      - name: Run `packer validate`
        id: validate
        run: "packer validate ./image.pkr.hcl"

      - name: Run `packer build`
        id: build
        run: |
          packer build \
            -var "aws_access_key=${{ secrets.PLANE_DEV_AWS_ACCESS_KEY_ID }}" \
            -var "aws_secret_key=${{ secrets.PLANE_DEV_AWS_SECRET_ACCESS_KEY }}" \
            ./image.pkr.hcl

      - name: Extract AMI Information
        id: ami_info
        run: |
          # Extract AMI ID and other details from manifest
          AMI_ID=$(jq -r '.builds[-1].artifact_id' manifest.json | cut -d ":" -f2)
          AMI_NAME=$(jq -r '.builds[-1].custom_data.ami_name' manifest.json)
          REGION=$(jq -r '.builds[-1].custom_data.region' manifest.json)
          BUILD_TIME=$(jq -r '.builds[-1].custom_data.build_time' manifest.json)
          
          # Add git information to manifest
          jq --arg branch "${{ github.ref_name }}" \
             --arg commit "${{ github.sha }}" \
             --arg build_time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
             '.builds[-1].custom_data += {git_branch: $branch, git_commit: $commit, build_timestamp: $build_time}' \
             manifest.json > enhanced-manifest.json
          mv enhanced-manifest.json manifest.json
          
          echo "AMI_ID=${AMI_ID}" >> $GITHUB_OUTPUT
          echo "AMI_NAME=${AMI_NAME}" >> $GITHUB_OUTPUT
          echo "REGION=${REGION}" >> $GITHUB_OUTPUT
          
          echo "âœ… AMI built successfully!"
          echo "ðŸ”¹ AMI ID: ${AMI_ID}"
          echo "ðŸ”¹ AMI Name: ${AMI_NAME}"
          echo "ðŸ”¹ Region: ${REGION}"
          echo "ðŸ”¹ Build Time: ${BUILD_TIME}"

      - name: Store Manifest in S3
        run: |
          # Store the current manifest as latest
          aws s3 cp manifest.json s3://${{ env.MANIFEST_BUCKET }}/plane-ce/ami/manifests/latest-manifest.json
          
          # Also store a versioned copy
          aws s3 cp manifest.json "s3://${{ env.MANIFEST_BUCKET }}/plane-ce/ami/manifests/manifest-${{ github.sha }}.json"

      - name: Upload Build Manifest as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: packer-manifest
          path: manifest.json
          retention-days: 30

      - name: Create Build Summary
        run: |
          echo "### ðŸš€ Plane CE AMI Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Detail | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
          echo "| AMI ID | \`${{ steps.ami_info.outputs.AMI_ID }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| AMI Name | \`${{ steps.ami_info.outputs.AMI_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Region | \`${{ steps.ami_info.outputs.REGION }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Git Branch | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Git Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY

      - name: Tag AMI
        run: |
          aws ec2 create-tags \
            --resources ${{ steps.ami_info.outputs.AMI_ID }} \
            --tags \
              Key=GitBranch,Value=${{ github.ref_name }} \
              Key=GitCommit,Value=${{ github.sha }} \
              Key=BuildTime,Value=$(date -u +"%Y-%m-%dT%H:%M:%SZ")