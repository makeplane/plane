name: Appliance Build CE

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release/Branch Tag'
        required: true
        default: 'v0.0.0'
      build_aws_appliance:
        description: 'Build AWS Appliance'
        required: true
        type: boolean
        default: false
      build_do_appliance:
        description: 'Build Digital Ocean Appliance'
        required: true
        type: boolean
        default: false
      ami_name_prefix:
        description: 'AMI Name Prefix'
        required: true
        default: 'plane-ce'
      aws_manifest_bucket:
        description: 'AWS Manifest Bucket'
        required: true
        default: 'plane-terraform-state-dev'
      aws_vpc_cidr:
        description: 'AWS VPC CIDR'
        required: true
        default: '10.22.0.0/16'
      aws_subnet_cidr:
        description: 'AWS Subnet CIDR'
        required: true
        default: '10.22.1.0/24'
      aws_vpc_region:
        description: 'AWS VPC Region'
        required: true
        default: 'us-east-1'
      do_region:
        description: 'Digital Ocean Region'
        required: true
        default: 'BLR1'

env:
  DEFAULT_TAG_NAME: ${{ inputs.release_tag }}
  AMI_NAME_PREFIX: ${{ inputs.ami_name_prefix || 'plane-ce' }}
  
  AWS_ACCESS_KEY: ${{ secrets.PLANE_DEV_AWS_ACCESS_KEY_ID }}
  AWS_SECRET_KEY: ${{ secrets.PLANE_DEV_AWS_SECRET_ACCESS_KEY }}
  AWS_MANIFEST_BUCKET: plane-terraform-state-dev

  AWS_VPC_CIDR: ${{ inputs.aws_vpc_cidr || '10.22.0.0/16' }}
  AWS_SUBNET_CIDR: ${{ inputs.aws_subnet_cidr || '10.22.1.0/24' }}
  AWS_VPC_REGION: ${{ inputs.aws_vpc_region || 'us-east-1' }}
  AWS_BASE_IMAGE_OWNER: '099720109477'
  
  DO_REGION: ${{ inputs.do_region || 'BLR1' }}
  DO_TOKEN: ${{ secrets.PLANE_DEV_DIGITAL_OCEAN_TOKEN }}

jobs:
  build_setup:
    runs-on: ubuntu-22.04
    outputs:
      tag_name: ${{ steps.set_env_variables.outputs.TAG_NAME }}
      admin_image: ${{ steps.set_env_variables.outputs.ADMIN_IMAGE }}
      web_image: ${{ steps.set_env_variables.outputs.WEB_IMAGE }}
      space_image: ${{ steps.set_env_variables.outputs.SPACE_IMAGE }}
      backend_image: ${{ steps.set_env_variables.outputs.BACKEND_IMAGE }}
      live_image: ${{ steps.set_env_variables.outputs.LIVE_IMAGE }}
    steps:
      - name: Prepare Environment
        id: set_env_variables
        run: |
          #  if the action is workflow_dispatch, then use the github.ref_name
          
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG_NAME=${{ github.ref_name }}
          else
            # get the selected branch/tag name and flatten it 
            TAG_NAME=${{ env.DEFAULT_TAG_NAME }}
          fi

          TAG_NAME=${TAG_NAME//\//-}

          echo "TAG_NAME=${TAG_NAME}" >> $GITHUB_OUTPUT

          echo "ADMIN_IMAGE=makeplane/plane-admin" >> $GITHUB_OUTPUT
          echo "WEB_IMAGE=makeplane/plane-frontend" >> $GITHUB_OUTPUT
          echo "SPACE_IMAGE=makeplane/plane-space" >> $GITHUB_OUTPUT
          echo "BACKEND_IMAGE=makeplane/plane-backend" >> $GITHUB_OUTPUT
          echo "LIVE_IMAGE=makeplane/plane-live" >> $GITHUB_OUTPUT

  build_admin:
    needs: build_setup
    runs-on: ubuntu-22.04
    steps:
      - name: Export Builder Stage Content
        run: |
          IMAGE_NAME=${{ needs.build_setup.outputs.admin_image }}
          TAG_NAME=${{ needs.build_setup.outputs.tag_name }}

          # Create a temporary container from the builder stage
          CONTAINER_ID=$(docker create --platform=linux/amd64 -q ${IMAGE_NAME}:${TAG_NAME})
          
          # Create publish directory
          mkdir -p admin-dist
          
          # Copy the /app contents from the container
          docker cp $CONTAINER_ID:/app/. admin-dist/
          
          # Remove the temporary container
          docker rm $CONTAINER_ID
          
          # Create a tar archive
          tar -czf admin-dist.tar.gz admin-dist/

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: admin-dist
          path: admin-dist.tar.gz
          retention-days: 1
    
  build_web:
    needs: build_setup
    runs-on: ubuntu-22.04
    steps:
      - name: Export Builder Stage Content
        run: |
          IMAGE_NAME=${{ needs.build_setup.outputs.web_image }}
          TAG_NAME=${{ needs.build_setup.outputs.tag_name }}

          # Create a temporary container from the builder stage
          CONTAINER_ID=$(docker create --platform=linux/amd64 -q ${IMAGE_NAME}:${TAG_NAME})
          
          # Create publish directory
          mkdir -p web-dist
          
          # Copy the /app contents from the container
          docker cp $CONTAINER_ID:/app/. web-dist/
          
          # Remove the temporary container
          docker rm $CONTAINER_ID
          
          # Create a tar archive
          tar -czf web-dist.tar.gz web-dist/

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: web-dist
          path: web-dist.tar.gz
          retention-days: 1

  build_space:
    needs: build_setup
    runs-on: ubuntu-22.04
    steps:
      - name: Export Builder Stage Content
        run: |
          IMAGE_NAME=${{ needs.build_setup.outputs.space_image }}
          TAG_NAME=${{ needs.build_setup.outputs.tag_name }}

          # Create a temporary container from the builder stage
          CONTAINER_ID=$(docker create --platform=linux/amd64 -q ${IMAGE_NAME}:${TAG_NAME})
          
          # Create publish directory
          mkdir -p space-dist
          
          # Copy the /app contents from the container
          docker cp $CONTAINER_ID:/app/. space-dist/
          
          # Remove the temporary container
          docker rm $CONTAINER_ID
          
          # Create a tar archive
          tar -czf space-dist.tar.gz space-dist/

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: space-dist
          path: space-dist.tar.gz
          retention-days: 1
 
  build_live:
    needs: build_setup
    runs-on: ubuntu-22.04
    steps:
      - name: Export Builder Stage Content
        run: |
          IMAGE_NAME=${{ needs.build_setup.outputs.live_image }}
          TAG_NAME=${{ needs.build_setup.outputs.tag_name }}

          # Create a temporary container from the builder stage
          CONTAINER_ID=$(docker create --platform=linux/amd64 -q ${IMAGE_NAME}:${TAG_NAME})
          
          # Create publish directory
          mkdir -p live-dist
          
          # Copy the /app contents from the container
          docker cp $CONTAINER_ID:/app/. live-dist/
          
          # Remove the temporary container
          docker rm $CONTAINER_ID
          
          # Create a tar archive
          tar -czf live-dist.tar.gz live-dist/

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: live-dist
          path: live-dist.tar.gz
          retention-days: 1

  build_backend:
    needs: build_setup
    runs-on: ubuntu-22.04
    steps:
      - name: Export Builder Stage Content
        run: |
          IMAGE_NAME=${{ needs.build_setup.outputs.backend_image }}
          TAG_NAME=${{ needs.build_setup.outputs.tag_name }}

          # Create a temporary container from the builder stage
          CONTAINER_ID=$(docker create --platform=linux/amd64 -q ${IMAGE_NAME}:${TAG_NAME})
          
          # Create publish directory
          mkdir -p backend-dist
          
          # Copy the /app contents from the container
          docker cp $CONTAINER_ID:/code/. backend-dist/
          
          # Remove the temporary container
          docker rm $CONTAINER_ID
          
          # Create a tar archive
          tar -czf backend-dist.tar.gz backend-dist/

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-dist
          path: backend-dist.tar.gz
          retention-days: 1
  
  build_do_appliance:
    if: inputs.build_do_appliance == true
    needs: [build_setup, build_admin, build_web, build_space, build_live, build_backend]
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: '*-dist'
          path: artifacts

      - name: Extract All Builds
        run: |
          # Create local directories
          mkdir -p plane-dist

          for dist in admin-dist web-dist space-dist live-dist backend-dist; do
            mv artifacts/${dist}/${dist}.tar.gz plane-dist/
          done
          cp -r ./deploy/packer/envs/*.env plane-dist/
          cp -r ./deploy/packer/svc/*.service plane-dist/
          cp ./deploy/packer/Caddyfile-ce plane-dist/Caddyfile
          cp ./deploy/packer/plane-ce.sh plane-dist/
          
          # Cleanup directories
          rm -rf artifacts 

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ env.AWS_SECRET_KEY }}
          aws-region: ${{ env.AWS_VPC_REGION }}

      - name: Download Previous Manifest
        run: |
          # Download the previous manifest from S3 if it exists
          aws s3 cp s3://${{ env.AWS_MANIFEST_BUCKET }}/plane-ce/ami/manifests/ce-digital-ocean-latest-manifest.json ./ce-digital-ocean-previous-manifest.json || true

      - name: Setup `packer`
        uses: hashicorp/setup-packer@main
        id: setup
        with:
          version: latest

      - name: Run `packer init`
        id: init
        run: "packer init ./deploy/packer/ce-digital-ocean.pkr.hcl"

      - name: Run `packer validate`
        id: validate
        run: "packer validate ./deploy/packer/ce-digital-ocean.pkr.hcl"

      - name: Run `packer build`
        id: build
        run: |
          packer build \
            -var "do_token=${{ env.DO_TOKEN }}" \
            -var "do_region=${{ env.DO_REGION }}" \
            -var "ami_name_prefix=${{ env.AMI_NAME_PREFIX }}-${{ needs.build_setup.outputs.tag_name }}" \
            ./deploy/packer/ce-digital-ocean.pkr.hcl

      - name: Extract AMI Information
        id: ami_info
        run: |
          # Extract AMI ID and other details from manifest
          AMI_ID=$(jq -r '.builds[-1].artifact_id' ce-digital-ocean-manifest.json | cut -d ":" -f2)
          AMI_NAME=$(jq -r '.builds[-1].custom_data.ami_name' ce-digital-ocean-manifest.json)
          REGION=$(jq -r '.builds[-1].custom_data.region' ce-digital-ocean-manifest.json)
          BUILD_TIME=$(jq -r '.builds[-1].build_time' ce-digital-ocean-manifest.json)
          
          # Add git information to manifest
          jq --arg branch "${{ github.ref_name }}" \
             --arg commit "${{ github.sha }}" \
             --arg build_time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
             '.builds[-1].custom_data += {git_branch: $branch, git_commit: $commit, build_timestamp: $build_time}' \
             ce-digital-ocean-manifest.json > enhanced-ce-digital-ocean-manifest.json
          mv enhanced-ce-digital-ocean-manifest.json ce-digital-ocean-manifest.json
         
          echo "AMI_ID=${AMI_ID}" >> $GITHUB_OUTPUT
          echo "AMI_NAME=${AMI_NAME}" >> $GITHUB_OUTPUT
          echo "REGION=${REGION}" >> $GITHUB_OUTPUT
          
          echo "✅ AMI built successfully!"
          echo "🔹 AMI ID: ${DROPLET_ID}"
          echo "🔹 AMI Name: ${DROPLET_NAME}"
          echo "🔹 Region: ${DROPLET_REGION}"
          echo "🔹 Build Time: ${BUILD_TIME}"

      - name: Store Manifest in S3
        run: |
          # Store the current manifest as latest
          aws s3 cp ce-digital-ocean-manifest.json s3://${{ env.AWS_MANIFEST_BUCKET }}/plane-ce/ami/manifests/ce-digital-ocean-latest-manifest.json
          
          # Also store a versioned copy
          aws s3 cp ce-digital-ocean-manifest.json "s3://${{ env.AWS_MANIFEST_BUCKET }}/plane-ce/ami/manifests/ce-digital-ocean-manifest-${{ github.sha }}.json"

      - name: Upload Build Manifest as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ce-digital-ocean-manifest
          path: ce-digital-ocean-manifest.json
          retention-days: 5

      - name: Create Build Summary
        run: |
          echo "### 🚀 Plane CE Digital Ocean Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Detail | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
          echo "| Droplet ID | \`${{ steps.ami_info.outputs.AMI_ID }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Droplet Name | \`${{ steps.ami_info.outputs.AMI_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Droplet Region | \`${{ steps.ami_info.outputs.REGION }}\` |" >> $GITHUB_STEP_SUMMARY

  build_aws_appliance:
    if: inputs.build_aws_appliance == true
    needs: [build_setup, build_admin, build_web, build_space, build_live, build_backend]
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: '*-dist'
          path: artifacts

      - name: Extract All Builds
        run: |
          # Create local directories
          mkdir -p plane-dist

          for dist in admin-dist web-dist space-dist live-dist backend-dist; do
            mv artifacts/${dist}/${dist}.tar.gz plane-dist/
          done
          cp -r ./deploy/packer/envs/*.env plane-dist/
          cp -r ./deploy/packer/svc/*.service plane-dist/
          cp ./deploy/packer/Caddyfile-ce plane-dist/Caddyfile
          cp ./deploy/packer/plane-ce.sh plane-dist/
          
          # Cleanup directories
          rm -rf artifacts 

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ env.AWS_SECRET_KEY }}
          aws-region: ${{ env.AWS_VPC_REGION }}

      - name: Download Previous Manifest
        run: |
          # Download the previous manifest from S3 if it exists
          aws s3 cp s3://${{ env.AWS_MANIFEST_BUCKET }}/plane-ce/ami/manifests/ce-aws-ami-latest-manifest.json ./ce-aws-ami-previous-manifest.json || true

      - name: Setup `packer`
        uses: hashicorp/setup-packer@main
        id: setup
        with:
          version: latest

      - name: Run `packer init`
        id: init
        run: "packer init ./deploy/packer/ce-aws-ami.pkr.hcl"

      - name: Run `packer validate`
        id: validate
        run: "packer validate ./deploy/packer/ce-aws-ami.pkr.hcl"

      - name: Run `packer build`
        id: build
        run: |
          packer build \
            -var "aws_access_key=${{ env.AWS_ACCESS_KEY }}" \
            -var "aws_secret_key=${{ env.AWS_SECRET_KEY }}" \
            -var "ami_name_prefix=${{ env.AMI_NAME_PREFIX }}-${{ needs.build_setup.outputs.tag_name }}" \
            -var "vpc_cidr=${{ env.AWS_VPC_CIDR }}" \
            -var "subnet_cidr=${{ env.AWS_SUBNET_CIDR }}" \
            -var "base_image_owner=${{ env.AWS_BASE_IMAGE_OWNER }}" \
            ./deploy/packer/ce-aws-ami.pkr.hcl

      - name: Cleanup Old AMIs
        if: hashFiles('ce-aws-ami-previous-manifest.json') != ''
        run: |
          OLD_AMI_ID=$(jq -r '.builds[-1].artifact_id' ce-aws-ami-previous-manifest.json | cut -d ":" -f2)
          if [ ! -z "$OLD_AMI_ID" ]; then
            echo "Found previous AMI: $OLD_AMI_ID"
            # Deregister the old AMI
            aws ec2 deregister-image --image-id "$OLD_AMI_ID" || true
            echo "Deregistered previous AMI: $OLD_AMI_ID"
          fi

      - name: Extract AMI Information
        id: ami_info
        run: |
          # Extract AMI ID and other details from manifest
          AMI_ID=$(jq -r '.builds[-1].artifact_id' ce-aws-ami-manifest.json | cut -d ":" -f2)
          AMI_NAME=$(jq -r '.builds[-1].custom_data.ami_name' ce-aws-ami-manifest.json)
          REGION=$(jq -r '.builds[-1].custom_data.region' ce-aws-ami-manifest.json)
          BUILD_TIME=$(jq -r '.builds[-1].custom_data.build_time' ce-aws-ami-manifest.json)
          
          # Add git information to manifest
          jq --arg branch "${{ github.ref_name }}" \
             --arg commit "${{ github.sha }}" \
             --arg build_time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
             '.builds[-1].custom_data += {git_branch: $branch, git_commit: $commit, build_timestamp: $build_time}' \
             ce-aws-ami-manifest.json > enhanced-ce-aws-ami-manifest.json
          mv enhanced-ce-aws-ami-manifest.json ce-aws-ami-manifest.json
          
          echo "AMI_ID=${AMI_ID}" >> $GITHUB_OUTPUT
          echo "AMI_NAME=${AMI_NAME}" >> $GITHUB_OUTPUT
          echo "REGION=${REGION}" >> $GITHUB_OUTPUT
          
          echo "✅ AMI built successfully!"
          echo "🔹 AMI ID: ${AMI_ID}"
          echo "🔹 AMI Name: ${AMI_NAME}"
          echo "🔹 Region: ${REGION}"
          echo "🔹 Build Time: ${BUILD_TIME}"

      - name: Store Manifest in S3
        run: |
          # Store the current manifest as latest
          aws s3 cp ce-aws-ami-manifest.json s3://${{ env.AWS_MANIFEST_BUCKET }}/plane-ce/ami/manifests/ce-aws-ami-latest-manifest.json
          
          # Also store a versioned copy
          aws s3 cp ce-aws-ami-manifest.json "s3://${{ env.AWS_MANIFEST_BUCKET }}/plane-ce/ami/manifests/ce-aws-ami-manifest-${{ github.sha }}.json"

      - name: Upload Build Manifest as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ce-aws-ami-manifest
          path: ce-aws-ami-manifest.json
          retention-days: 30

      - name: Create Build Summary
        run: |
          echo "### 🚀 Plane CE AWS Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Detail | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
          echo "| AMI ID | \`${{ steps.ami_info.outputs.AMI_ID }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| AMI Name | \`${{ steps.ami_info.outputs.AMI_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Region | \`${{ steps.ami_info.outputs.REGION }}\` |" >> $GITHUB_STEP_SUMMARY

      - name: Tag AMI
        run: |
          aws ec2 create-tags \
            --resources ${{ steps.ami_info.outputs.AMI_ID }} \
            --tags \
              Key=GitBranch,Value=${{ github.ref_name }} \
              Key=GitCommit,Value=${{ github.sha }} \
              Key=BuildTime,Value=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
